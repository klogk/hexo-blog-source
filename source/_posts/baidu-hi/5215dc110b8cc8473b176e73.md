---
title: 多校联训北京师范大学专场解题报告
layout: post
tags: ['public', 'post', 'unber', ]
time: 2009-08-08 18:17
mathjax: false
---
<b>这篇文章最初发布在本人的百度空间：[http://hi.baidu.com/syncth/item/5215dc110b8cc8473b176e73](http://hi.baidu.com/syncth/item/5215dc110b8cc8473b176e73)，后来迁移到此处</b>

Problem A: Another snake<p>从题目可以知道我们在搜索过程中要新加入一个点的时候判断旋转角度只要知道之前两个点就够了。可以用状态压缩存储已经加入到这个状态的所有点。难点在于如何判断是否相交。因为每次我们都是逆时针旋转180以内。可以形成一种凸的形状。这样每次加入一个点和最后一个点连成直线。我们只要判断之前的点走在这条直线的一侧就可以解决判断是否相交了。</p><p>// 判断部分</p><p>bool correctTurn(int a, int b, int c) {</p><p>  int ux = X[b]-X[a], uy=Y[b]-Y[a];</p><p>  int vx = X[c]-X[b], vy=Y[c]-Y[b];</p><p>  int crossProduct = ux*vy - vx*uy;</p><p>  int dotProduct = ux*vx + uy*vy;</p><p>  if (crossProduct != 0) return (crossProduct &gt; 0);</p><p>  return dotProduct &gt;= 0;</p><p>}</p><p> </p><p>//状态转移部分</p><p>for (int next = 0; next &lt; N; next++) {</p><p>     if (used &amp; (1 &lt;&lt; next)) continue;</p><p>     bool good = true;</p><p>     for (int i = 0; i &lt; N + 1; i++)</p><p>         if ((i == N) || (used &amp; (1 &lt;&lt; i)))</p><p>             if (!correctTurn(i, last, next)) good = false;</p><p>     if (good) res = max(res, 1 + solve(used | (1 &lt;&lt; next), next, last));</p><p>}</p>Problem B: Bomb Game<p>利用SG（Sprague-Grundy）函数在多图游戏中的性质解决。</p><p>SG函数在多图游戏中的性质：</p><p>对于多图游戏，每个图都有一个当前节点。两个游戏者轮流行动。每个人每次可以把某一个图中的当前节点沿着该点连出的有向边移动到另一个点。无法移动的那个人输。</p><p>设这些图的当前节点的SG值分别是A<sub>1</sub>, A<sub>2</sub>, …, A<sub>k</sub>，如果A<sub>1 </sub>XOR A<sub>2 </sub>XOR … XOR A<sub>k</sub> = 0{XOR表示按照位异或，也就是二进制下的不进位加法}，那么先手必败，否则必胜。</p><p>解题的关键点在于把这个游戏分解为多图游戏。</p><p>如果炸弹之间没有联系，都是独立的，那么就可以游戏分解为在若干个只有一个炸弹的棋盘上进行，这样就可以把这个游戏分解为多图游戏了。</p><p>炸弹之间的唯一联系在于，两个炸弹处于同一位置就会消失。</p><p>容易证明，如果一个局面对于先手有必胜策略，那么把上述规则删去之后，先手依然会有必胜策略。</p><p>这样就把原来的游戏分解成为多个只有一个炸弹的棋盘，假设只是在位置(i, j)有一个炸弹的棋盘的SG函数的值为SG<sub>i,j</sub>，那么有多个炸弹的棋盘的SG函数值为：</p><p><img src="/img/baidu-hi/b_11798e017016.jpg"/></p><p> </p><p>a<sub>i</sub>,b<sub>i</sub>表示棋盘(a<sub>i</sub>,b<sub>i</sub>)上有炸弹，并且如果i ≠ j则(a<sub>i</sub>,b<sub>i</sub>) ≠ (a<sub>j</sub>,b<sub>j</sub>)。</p><p>根据SG函数在多图游戏中的性质，如果这个值为0，则先手必败，反之必胜。</p><p>下面是计算SG<sub>i,j</sub>方法：</p><p>边界：如果i和j其中有一个为1，SG<sub>i,j</sub> ＝ i × j － 1。</p><p>其他SG<sub>i,j</sub>的值可以从边界递推计算得出，计算方法直接依据游戏规则和SG函数的定义即可，具体过程可以参见标程。</p>Problem C: Connections between cities<p>一道lca的题目。由于图可能是森林，所以我们可以新建一个root节点，连一条边到每棵树上，就构成了一个新树。如果两个节点不相连，则其最近公共祖先必为root节点，否则 两点之间的最短距离等于两个点到根节点的距离之和减去二倍的最近祖先到根节点的距离。</p><p>所以此题时间复杂度为O(nlogn+m)  利用RMQ解决lca问题</p>Problem D: DNA Sequence<p>由题目对子串的限制,容易发现规律,满足条件的DNA序列一定是A,C和G,T交替出现的.不妨假设序列是以A或C开始的,那么偶数位置一定是G或T,奇数位置是A或C.</p><p>我们可以得到这样的一些复合命题：</p><p>1.如果2i+1位置是C,那么2i+2位置一定是T</p><p>2.如果2i+1位置是C,2i位置一定是T</p><p>3.如果2i位置是G,那么2i-1位置一定是A</p><p>4.如果2i位置是G,2i+1位置一定是A</p><p>再来看限制条件,某些位置上的字母互不相同,前面已经知道奇偶位上的字母肯定是不同的,于是不需要考虑,只需奇偶位分开考虑.另外,如果要求有超过两个以上的奇数位或者偶数位互不相同,那也是不可满足的,可以直接输出No.考虑两个同奇偶的位置上的约束.</p><p>如果要求2i和2k位置上不同,又可以得到下面的复合命题</p><p>1.2i位置上为G,那么2k位置上为T</p><p>2.2i位置上为T,那么2k位置上为G</p><p>3.2k位置上为T,那么2i位置上为G</p><p>4.2k位置上为G,那么2i位置上为T</p><p>同理,如果要求2i+1和2k+1位置上不同,也可以得到类似的复合命题.</p><p>如果存在满足条件的DNA序列,那么上面的命题应该是可以通过条件命题的适当选择避免矛盾.注意,代表每个位置选择的两个命题必选其一.但是有时必然会有矛盾.例如,命题1:2i位置选G,命题2:2i位置选T,如果命题1能够推导得到命题2,并且还有命题2能够推导得到命题1.这种情况下无论如何选择2i位置的字符都会产生矛盾..</p><p>使用强连通分量来解决这个问题.对应于上面所有的条件命题或者结论命题,分别用有向图中的点来表示,如果命题s能够推出t,那么从s到t连一条有向边.问题转化成为s和s的对立命题是否在同一强连通分支中,如果在,那么就不存在满足条件的DNA序列,否则就可以构造满足条件的DNA序列.</p>Problem E: Ellipse, again and again<p>简单计算几何.答案其实和Q点的位置无关,为a^2*b^2.可以用解析几何推导得到这一答案.</p><p>也可以直接计算出Q点的位置,然后依次算出d,QF1,QF2再得到结果.</p>Problem F: Florid Banner<p>观察可以发现，虽然旗面大小为M*N，但由于小旗的大小是1*L，总的最小开销可以看作是每一层的最小开销之和。题目就简化为给出一些子串的价格，由这些子串构成目标串所需的最小开销，这是简单的DP问题。由于子串长度不超过20，颜色种类数不超过30，通过构造子串的TRIE，可以优化时间复杂度。</p>Problem G: Great World of Goo<p>很容易可以看出，题目是要求完全匹配的数目。完全匹配好求，但是数目就不太好求了，所以我们采用了搜索的方法。这个问题可以转换成一个最大为m*n行， 2*n列的精确覆盖问题（行表示每一个GOO BALL对应在某一个点，列则表示覆盖的），而稀疏矩阵的精确覆盖问题就可以采用DLX较快速的求解。舞蹈链的具体实现算法请参考KNUTH的论文。</p>Problem H: HEHE<p>He[p^k]=2 He[N]为积性函数 </p><p>当N=p1^k1……pn^kn 时 He[N]=2^n</p><p>这样求HeHe[N] 就是统计1-N中每个数质因数的个数之和t，HeHe[N]=2^t</p><p>我们可以转化为 统计1-N中每个质数p在t中出现次数，p的每个倍数在t中的贡献是1，故p对t的贡献为 N/P.</p>Problem I: Ingredient<p>题目给出，任意一种酒都不能由其它酒勾兑出来，因此可以判断酒的原料组成的N×N矩阵是线性无关的，因此保证此线性方程组的解唯一。</p><p>基于分式，对给出的N×（N+1）的线性方程进行高斯消元，可得每种酒的使用数量，分母的最小公倍数即新酒的数量。</p><p>当高斯消元后得到的解存在负数时，认为无解。</p>Problem J: Jack’s Struggle<p>简单的动态规划，类似于最长上升子序列的求解方法。</p><p>把所有任务按照完成时间排序，之后就是求最长上升子序列，这里的两个任务之间的大于关系定义为任务i 大于任务 j，当且仅当任务i的完成时间和任务j的完成时间之差不小于两任务完成地点之间的曼哈顿距离。</p>
